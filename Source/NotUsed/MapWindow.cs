//------------------------------------------------------------------------------
// <auto-generated>
//     Este código fue generado por una herramienta.
//     Versión de runtime:4.0.30319.34003
//
//     Los cambios en este archivo podrían causar un comportamiento incorrecto y se perderán si
//     se vuelve a generar el código.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEditor;
using UnityEngine;
using System.Collections.Generic;

public class MapWindow : EditorWindow
{
	[MenuItem("Window/Map Window")]
	static void ShowWindow () {
		EditorWindow.GetWindow(typeof(MapWindow));
	}

	Map map;

	public MapWindow ()
	{
		SceneView.onSceneGUIDelegate += this.OnSceneGUI;
		this.map = MapManager.getInstance().createNewMap();
	}

	void OnDestroy() 
	{
		SceneView.onSceneGUIDelegate -= this.OnSceneGUI;
	}

	/** 
	 * Window options
	 * */

	bool editingMode;
	bool paintingMode;
	bool fixView;
	bool setPerspective = false;
	GameObject baseCell;
	Texture2D baseTile;
	int width;
	int height;

	int cellSize;

	int gridHeight = 0;
	float angle;

	bool movingGrid = false;
	float startingMousePosition;
	int startingGridHeight;

	void startMovingGrid(){
		movingGrid = true;
		startingMousePosition = Event.current.mousePosition.y;
		startingGridHeight = gridHeight;
	}

	void endMovingGrid(){
		movingGrid = false;
	}

	const float movingInterval = 30;
	void moveGrid(){
		if(movingGrid){
			float mouseDifference = startingMousePosition - Event.current.mousePosition.y;
			int movingTimes = Mathf.FloorToInt(mouseDifference / movingInterval);

			gridHeight = startingGridHeight + movingTimes;
			this.Repaint();
		}
	}

	int pulsado;
	int levantado;
	int movido;

	Quaternion fixedRotation;
	void backUpAngle(){
		fixedRotation = SceneView.lastActiveSceneView.camera.transform.rotation;
	}


	Texture2D paintingTexture;
	int isoTextureIndex;
	IsoTexture paintingIsoTexture;

	void OnGUI(){
		map.CellPrefab = UnityEditor.EditorGUILayout.ObjectField("Base Cell", map.CellPrefab, typeof(GameObject), true) as GameObject;
		baseTile = UnityEditor.EditorGUILayout.ObjectField("Base tile", baseTile, typeof(Texture2D), true,GUILayout.MaxHeight(16)) as Texture2D;

		if(cellSize < 1)
			cellSize = 1;
		map.setCellSize(cellSize);
		cellSize = UnityEditor.EditorGUILayout.IntField("Cell size", cellSize);

		/*width = UnityEditor.EditorGUILayout.IntField("Tile size", (baseTile!=null)?baseTile.width:0);
		height = UnityEditor.EditorGUILayout.IntField("Tile size", (baseTile!=null)?baseTile.height:0);*/

		bool lastFixView = fixView;
		fixView = EditorGUILayout.Toggle("Fix perspective",fixView);
		
		if(lastFixView == false && fixView == true){
			backUpAngle();
		}

		/****************
		 * Creating mode
		 **************** */

		GUIStyle style = new GUIStyle();
		style.padding = new RectOffset(2,2,2,2);
		editingMode = EditorGUILayout.BeginToggleGroup("Editing mode",editingMode);
		{
			Event e = Event.current;
			
			GUIContent buttonText = new GUIContent("Set camera to game view");
			Rect buttonRect = GUILayoutUtility.GetRect(buttonText, style);
			
			if (e.isMouse && buttonRect.Contains(e.mousePosition)) { 
				if(e.type == EventType.MouseUp){
					setPerspective = true;
				}
			} 
			
			GUI.Button(buttonRect, buttonText);
			gridHeight = EditorGUILayout.IntField("Grid Height", gridHeight);
		}
		EditorGUILayout.EndToggleGroup();

		/*****************
		 * Painting mode
		 ***************** */

		paintingMode = EditorGUILayout.BeginToggleGroup("Painting mode",paintingMode);


		EditorGUILayout.BeginHorizontal();

			paintingTexture = UnityEditor.EditorGUILayout.ObjectField("Tile", paintingTexture, typeof(Texture2D), false, null) as Texture2D;
			
			if(paintingTexture != null){
				IsoTexture[] textures = TextureManager.getInstance ().textureList (paintingTexture);
				List<string> texts = new List<string> ();

				//paintingIsoTexture = textures.Length;
				foreach (IsoTexture it in textures)
					texts.Add (it.name);

				texts.Add("None");
				//TODO CAMBIOS EN LA LISTA DEBERIAN DESELEECIONAR EL ELEMENTO ACTUAL SI ESTE YA NO ESTA EN LA LISTA
				isoTextureIndex = UnityEditor.EditorGUILayout.Popup(isoTextureIndex,texts.ToArray());
				if(isoTextureIndex == textures.Length)
					paintingIsoTexture = null;
				else
					paintingIsoTexture = textures[isoTextureIndex];
			}
		EditorGUILayout.EndHorizontal();

		//isoTexture = (IsoTexture)EditorGUILayout.ObjectField(isoTexture,typeof(IsoTexture),true);

	}

	Vector3 getMousePositionOverGrid(){
		Vector2 mousePosition = Event.current.mousePosition;
		Ray rayo = HandleUtility.GUIPointToWorldRay(mousePosition);
		
		//float t = - (rayo.origin.y / rayo.direction.y);
		float a = (gridHeight - rayo.origin.y) / rayo.direction.y;
		
		
		Vector3 puntoDeCorte =
			new Vector3(rayo.origin.x + a*rayo.direction.x,
			            rayo.origin.y + a*rayo.direction.y,
			            rayo.origin.z + a*rayo.direction.z);

		return fromPointToGrid(puntoDeCorte);
	}

	Vector3 fromPointToGrid(Vector3 point){
		float xTile = Mathf.Floor(point.x / cellSize) * cellSize + 0.5f * cellSize;
		float zTile = Mathf.Floor(point.z / cellSize) * cellSize + 0.5f * cellSize;
		return new Vector3(xTile, gridHeight, zTile);
	}

	GameObject selected;
	bool creating = false;
	bool painting = false;

	bool collectTexture = false;

	void OnSceneGUI (SceneView sceneView){



		if(setPerspective){
			/*
			Selection.transforms
			*/
			setPerspective = false;
			angle = 30;
			if(baseTile!= null){
				float angulo = Mathf.Rad2Deg * Mathf.Acos(baseTile.height / (baseTile.width*1f));
				angle = 90f - angulo;
			}
			sceneView.LookAtDirect(sceneView.pivot,Quaternion.Euler(angle, 45, 0));
			sceneView.orthographic = true;

			if(fixView)
				fixedRotation = Quaternion.Euler(angle, 45, 0);

			this.Repaint();
		}

		if(fixView){
			sceneView.LookAtDirect(sceneView.pivot,fixedRotation);
		}



		/* Fixing movement */
		//Debug.Log(Event.current.GetTypeForControl(GUIUtility.GetControlID(FocusType.Passive)).ToString());
		if(Event.current.rawType == EventType.used){

			//Debug.Log("estan seleccionando"  + ":");
			if(Event.current.button == 0){

				/*if(Event.current.type == EventType.MouseDown)
					HandleUtility.AddDefaultControl(GUIUtility.GetControlID(FocusType.Native));*/
				//Debug.Log("estan pulsando! "+(Event.current.type == EventType.MouseUp));
				GameObject[] gos = Selection.gameObjects;
				foreach(GameObject go in gos){

					map.updateCell(go.GetComponent<Cell>(), Event.current.type == EventType.MouseUp);
					/*Vector3 pointInGrill = fromPointToGrid(go.transform.position);
						go.transform.position = new Vector3(pointInGrill.x, go.transform.position.y, pointInGrill.z);*/

				}
			}
		}

		if(editingMode)
		{
			HandleUtility.AddDefaultControl(GUIUtility.GetControlID(FocusType.Passive));
			if(Event.current.isMouse){
				if(Event.current.button == 0){
					if(editingMode){
						if(Event.current.type == EventType.MouseDown){
							creating = true;
							map.addCell(getMousePositionOverGrid());
						}else if(Event.current.type == EventType.MouseUp){
							creating = false;
						}else{
							if(creating)
								map.addCell(getMousePositionOverGrid());
						}
					}
				}

				if(Event.current.button == 1){
					if(editingMode){
						if(Event.current.type == EventType.MouseDown){
							startMovingGrid();
						}else if(Event.current.type == EventType.MouseUp){
							endMovingGrid();
						}else{
							moveGrid();
						}
					}
				}
			}

			if(!paintingMode){
				Vector3 centerGridPoint = getMousePositionOverGrid();

				Vector3[] puntos = new Vector3[4];
				puntos[0] = new Vector3(centerGridPoint.x - cellSize/2.0f,centerGridPoint.y,centerGridPoint.z - cellSize/2.0f);
				puntos[1] = new Vector3(centerGridPoint.x - cellSize/2.0f,centerGridPoint.y,centerGridPoint.z + cellSize/2.0f);
				puntos[2] = new Vector3(centerGridPoint.x + cellSize/2.0f,centerGridPoint.y,centerGridPoint.z + cellSize/2.0f);
				puntos[3] = new Vector3(centerGridPoint.x + cellSize/2.0f,centerGridPoint.y,centerGridPoint.z - cellSize/2.0f);
				Handles.DrawSolidRectangleWithOutline(puntos, Color.yellow, Color.white);
			}
		}



		if(paintingMode){

			HandleUtility.AddDefaultControl(GUIUtility.GetControlID(FocusType.Passive));
			RaycastHit info = new RaycastHit();

			Ray ray = HandleUtility.GUIPointToWorldRay(Event.current.mousePosition);
			if(Physics.Raycast(ray, out info/*, LayerMask.NameToLayer("Cells Layer")*/)) //TODO Arreglar esto porque al parecer la distancia no funciona correctamente
				selected = info.collider.gameObject;
			else
				selected = null;

			bool paintLater = false;
			bool backupTextures = false;
			if(Event.current.isMouse){
				if(Event.current.button == 0)
				{
					if(Event.current.shift){
						if(Event.current.type == EventType.mouseDown){
							collectTexture = true;
						}
						if(collectTexture && Event.current.type != EventType.MouseUp){
							backupTextures = true;
						}else{
							collectTexture = false;
						}
					}
					else
					{
						if(Event.current.type == EventType.MouseDown){
							painting = true;
							paintLater = true;
						}else if(Event.current.type == EventType.MouseUp){
							painting = false;
						}else{
							if(painting){
								paintLater = true;

							}
						}
					}
				}
			}

			if(selected != null){

				Cell cs = selected.GetComponent<Cell>();
				Face f = cs.getFaceByPoint(info.point);

				if(f!=null){

					if(paintLater){
						if(paintingTexture != null){
							f.Texture = paintingTexture;
							f.TextureMapping = paintingIsoTexture;
							cs.refresh();
						}
					}

					if(backupTextures){
						this.paintingTexture = f.Texture;
						IsoTexture[] isoTextures = TextureManager.getInstance().textureList(paintingTexture);
						if(f.TextureMapping != null){
							int texture = isoTextures.Length;
							for(int i = 0; i< isoTextures.Length; i++)
								if(f.TextureMapping == isoTextures[i]){texture = i; break;}
							this.isoTextureIndex = texture;
						}else
							this.isoTextureIndex = isoTextures.Length;
						this.Repaint();
					}

					//Debug.Log("He seleccionado!" + selected.name);
					Vector3 position = selected.transform.position;
					if(cs != null)
						position.y = cs.Height;

					Vector3[] vertex = f.SharedVertex;
					int[] indexes = f.VertexIndex;

					Vector3[] puntos = new Vector3[4];
					for(int i = 0; i< indexes.Length; i++){
						puntos[i] = cs.transform.TransformPoint(vertex[indexes[i]]);
					}

					if(indexes.Length == 3)
						puntos[3] = cs.transform.TransformPoint(vertex[indexes[2]]);


					Color color = Color.yellow;
					if(Event.current.shift)
						color = Color.blue;

					Handles.DrawSolidRectangleWithOutline(puntos, color, Color.white);
					//Debug.Log("He pintado el rectangulo en!" + position);
				}
			}
		}

		sceneView.Repaint();
	}
}

